

class product_node:
    def __init__(self, name, val):
        self.name = name
        self.minVal = val
        self.maxVal = val
        self.sumVal = val
    


class SegmentTree:
    def __init__(self, size):
        self.size = size
        val = product_node(0, "")
        self.tree = val * (4 * size)

    def update(self, node, left, right, idx, val):
        if left == right:
            self.tree[node].setVal(val)
            return
        mid = (left + right) // 2
        if idx <= mid:
            self.update(2 * node, left, mid, idx, val)
        else:
            self.update(2 * node + 1, mid + 1, right, idx, val)
        
        self.tree[node].sumVal = self.tree[2 * node].sumVal + self.tree[2 * node + 1].sumVal

    def get_total_sum(self, node, left, right, Lrange, Rrange):
        if(Rrange < left or right < Lrange):
            return 0
        if(Lrange <= left and Rrange >= right):
            return self.tree[node].sumVal
        mid = (left + right)//2
        return self.get_total_sum(node * 2, left, mid, Lrange, Rrange) + self.get_total_sum(node * 2 + 1, mid+1, right, Lrange, Rrange)
        
    def add(self, node, left, right, val):
        if left == right:
            if self.tree[node].minVal <= val.minVal:
                self.tree[2 * node] = self.tree[node]
                self.tree[2 * node + 1] = val
            else :
                self.tree[2 * node] = val
                self.tree[2 * node + 1] = self.tree[node]
        else:
            if self.tree[node].minVal > val.minval or self.tree[node].maxVal < val.minval:
                return
            mid = (left + right)/2
            self.add(node * 2, left, mid, val)
            self.add(node * 2 + 1, mid + 1, right, val)
        self.tree[node].minVal = min(self.tree[2 * node].minVal, self.tree[2 * node + 1].minVal)
        self.tree[node].maxVal = max(self.tree[2 * node].maxVal, self.tree[2 * node + 1].maxVal)
        self.tree[node].sumVal = self.tree[2 * node].sumVal + self.tree[2 * node + 1].sumVal

    def min_Range_Query(self, node, left, right, Lrange, Rrange):
        if(Rrange < left or right < Lrange):
            return 0
        if(Lrange <= left and Rrange >= right):
            return self.tree[node].minVal
        mid = (left + right)//2
        return min(self.min_Range_Query(node * 2, left, mid, Lrange, Rrange), self.min_Range_Query(node * 2 + 1, mid + 1, right, Lrange, Rrange))
        
    def max_Range_Query(self, node, left, right, Lrange, Rrange):
        if(Rrange < left or right < Lrange):
            return 0
        if(Lrange <= left and Rrange >= right):
            return self.tree[node].minVal
        mid = (left + right)//2
        return max(self.max_Range_Query(node * 2, left, mid, Lrange, Rrange), self.max_Range_Query(node * 2 + 1, mid + 1, right, Lrange, Rrange))
